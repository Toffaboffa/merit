<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slutlig antagning – Örebro 2025 (stabil parser)</title>
  <link rel="icon" href="data:," />
  <style>
    :root{ --bg:#0b0f14; --fg:#e7effa; --muted:#94a3b8; --panel:#0f172a; --accent:#22c55e; --border:#1f2937; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:16px 20px;background:#0f172a;border-bottom:1px solid var(--border);position:sticky;top:0;z-index:2}
    main{max-width:1100px;margin:0 auto;padding:20px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input[type=file]{flex:1;min-width:260px;padding:10px;border-radius:10px;border:1px solid var(--border);background:#0f172a;color:var(--fg)}
    button{padding:10px 14px;border-radius:10px;border:0;background:var(--accent);color:#05280f;font-weight:800;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    table{width:100%;border-collapse:collapse;margin-top:20px;background:#0f172a;border:1px solid var(--border);border-radius:12px;overflow:hidden}
    th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left;font-size:14px}
    th{background:#0d1326;position:sticky;top:88px}
    tr:hover td{background:#0c1222}
    .muted{color:var(--muted)}
    details{margin-top:14px}
    pre{white-space:pre-wrap;font-size:12px;background:#0f172a;border:1px solid var(--border);padding:10px;border-radius:8px;max-height:520px;overflow:auto}
    .toolbar{display:flex;gap:8px;margin-top:10px}
    .pill{display:inline-flex;gap:6px;align-items:center;background:#0d1326;border:1px solid #1f2937;border-radius:999px;padding:4px 10px;font-size:12px}
  </style>
</head>
<body>
  <header>
    <div class="row">
      <input id="pdfFile" type="file" accept="application/pdf" />
      <button id="parseFileBtn">Skapa lista från fil</button>
      <span id="status" class="muted"></span>
    </div>
    <div class="toolbar">
      <button id="exportCsvBtn" disabled>Exportera CSV</button>
      <span class="pill"><b>Resultat:</b>&nbsp;Skola · Inriktning · Lägsta Merit</span>
    </div>
  </header>

  <main>
    <table id="outTable" hidden>
      <thead>
        <tr><th>Skola</th><th>Inriktning</th><th>Lägsta Merit</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <details>
      <summary>Visa debug (första ~700 rader + matcher)</summary>
      <pre id="debugLines"></pre>
    </details>
  </main>

  <script type="module">
    import * as pdfjsLib from './vendor/pdfjs/pdf.mjs';
    const worker = new Worker('./vendor/pdfjs/pdf.worker.mjs', { type: 'module' });
    pdfjsLib.GlobalWorkerOptions.workerPort = worker;

    const statusEl = document.getElementById('status');
    const outTable = document.getElementById('outTable');
    const tbody = outTable.querySelector('tbody');
    const debugEl = document.getElementById('debugLines');
    const exportCsvBtn = document.getElementById('exportCsvBtn');

    const norm = s => (s||'')
      .replace(/\u00AD/g,'')                // mjukt bindestreck
      .replace(/[‐--–—―]/g,'-')            // alla bindestreck-varianter
      .replace(/\s+/g,' ')
      .trim();

    // PDF → radlistor genom y-kvantisering
    function buildLines(items){
      const rowsByY = new Map(); const yq = 2;
      for(const it of items){
        const y = it.transform[5], x = it.transform[4];
        const key = Math.round(y/yq)*yq;
        if(!rowsByY.has(key)) rowsByY.set(key, []);
        rowsByY.get(key).push({x,str: it.str||''});
      }
      const ys = Array.from(rowsByY.keys()).sort((a,b)=> b-a);
      const lines = [];
      for(const y of ys){
        const bits = rowsByY.get(y).sort((a,b)=> a.x-b.x).map(b=>b.str);
        let L = norm(bits.join(' '));
        if(!L) continue;
        L = L
          .replace(/forsta-?\s*handssokande/gi,'första-handssökande')
          .replace(/Lagsta\s+jamforelsetal/gi,'Lägsta jämförelsetal')
          .replace(/Medianvarde/gi,'Medianvärde')
          .replace(/\bAntal\s+forsta\b/gi,'Antal första');
        lines.push(L);
      }
      return lines;
    }

    // Heuristik för skolrad/rubrik
    const SCHOOL_HEADER = /^Slutlig antagningsstatistik för\b/i;
    function extractSchoolFromHeader(line){
      const m = line.match(/^Slutlig antagningsstatistik för\s+(.+?)\s*$/i);
      return m ? norm(m[1]) : null;
    }
    const looksLikeSchoolOnly = l =>
      !/\d/.test(l) &&
      /\b(skolan|gymnasiet|gymnasium|Kreativa Gy|Idrottsgym|Praktiska|Realgymnasiet|Rytmus|Affärsgymnasiet|Drottning Blankas Gy|Grillska Gymnasiet|NTI Gymnasiet|Jensen gymnasium|LBS Kreativa Gy|Yrkesgymnasiet|Karlskoga Idrottsgym)\b/i.test(l) &&
      l.length <= 60;

    // Startord för att splitta programlistan
    const STARTERS = [
      'Bygg- och anläggningsprogr\\.', 'Barn- och fritidsprogr\\.', 'El- och energiprogr\\.',
      'Ekonomiprogr\\.', 'Estetiska progr\\.', 'Försäljnings- och serviceprogr\\.',
      'Fordons- och transportprogr\\.', 'Industritekniska progr\\.', 'Naturvetenskapsprogr\\.',
      'Naturbruksprogr\\.', 'Restaurang- och livsmedelsprogr\\.', 'Samhällsvetenskapsprogr\\.',
      'Teknikprogr\\.', 'VVS- och fastighetsprogr\\.', 'Yrkesintro\\.',
      'Programinriktat val', 'IB Preparandår', 'Hotell- och turismprogr\\.', 'Frisör- och stylistprogr\\.', 'Frisör- och stylistprogrammet'
    ];
    const START_BOUND = new RegExp('(?:^|\\s)(' + STARTERS.join('|') + ')(?=\\s|$)', 'g');

    // Hjälpare
    const CODE_RE = /\b(AE|DEM|KAM|LS|PI|KA|RU|TU|VI|AFG|DBG|GRI|JGY|LBS|NTI|PRA|PRO|REA|RYT|YRK)\b/g;
    const NUM_RE  = /(\d{1,3}(?:[.,]\d+)?)/g;

    // Parse ett skolblock: kräver program[], lagsta[], (codes optional)
    function flushSection(acc, school, programs, lagsta, debug){
      const N = Math.min(programs.length, lagsta.length);
      if (!school || N===0) return;
      for(let i=0;i<N;i++){
        acc.push([school, programs[i], parseFloat(String(lagsta[i]).replace(',','.'))]);
      }
      debug.push(`  [MATCH] ${N} rader → ${school}`);
    }

    function splitProgramsFromBuffer(buf){
      // buf = 1..n rader efter "Studieväg" som innehåller programnamn
      const joined = buf.join(' ');
      // Lägg in delimiter före varje startord (utom första)
      const marked = joined.replace(START_BOUND, '|||$1');
      const parts = marked.split('|||').map(s=>norm(s)).filter(Boolean);
      return parts;
    }

    async function parsePdfFromArrayBuffer(buf){
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      const rows = [];
      const debug = [];

      let currentSchool = null;
      let headerJustSeen = false;

      // Buffers inom block
      let inPrograms = false;
      let progBuf = [];
      let programs = [];
      let expectCounts = 0;

      let codesBuf = [];
      let lagstaBuf = [];
      let collectingLagsta = false;

      function resetBlockState(){
        inPrograms = false;
        progBuf = [];
        programs = [];
        expectCounts = 0;
        codesBuf = [];
        lagstaBuf = [];
        collectingLagsta = false;
      }

      for(let p=1; p<=pdf.numPages; p++){
        const page = await pdf.getPage(p);
        const text = await page.getTextContent();
        const lines = buildLines(text.items);

        lines.slice(0,80).forEach(L => { if (debug.length<700) debug.push(L); });

        for (const Lraw of lines){
          const L = Lraw;

          // 1) Skolrubrik
          if (SCHOOL_HEADER.test(L)){
            const name = extractSchoolFromHeader(L);
            if (name){
              // flush ev föregående block
              if (currentSchool && programs.length && lagstaBuf.length){
                flushSection(rows, currentSchool, programs, lagstaBuf, debug);
              }
              currentSchool = name;
              debug.push(`[SKOLA] ${currentSchool}`);
              resetBlockState();
              continue;
            } else {
              // rubrik utan namn → nästa rad bär namnet
              headerJustSeen = true;
              continue;
            }
          }

          // 2) Skolnamn på separat rad efter rubrik
          if (headerJustSeen && looksLikeSchoolOnly(L)){
            if (currentSchool && programs.length && lagstaBuf.length){
              flushSection(rows, currentSchool, programs, lagstaBuf, debug);
            }
            currentSchool = norm(L);
            debug.push(`[SKOLA] ${currentSchool}`);
            resetBlockState();
            headerJustSeen = false;
            continue;
          }

          // Fångar även fristående “ensam skolrad” (PDF flödar ibland om)
          if (!headerJustSeen && looksLikeSchoolOnly(L) && !/Studieväg/i.test(L)){
            if (currentSchool && programs.length && lagstaBuf.length){
              flushSection(rows, currentSchool, programs, lagstaBuf, debug);
            }
            currentSchool = norm(L);
            debug.push(`[SKOLA] ${currentSchool}`);
            resetBlockState();
            continue;
          }

          if (!currentSchool) continue; // vi väntar på skolstart

          // 3) Start programtabell
          if (/^Studieväg$/i.test(L)){
            inPrograms = true;
            progBuf = [];
            programs = [];
            codesBuf = [];
            lagstaBuf = [];
            collectingLagsta = false;
            continue;
          }

          // 4) Samla programnamn (kan ligga på 1–3 rader)
          if (inPrograms){
            // Stoppvillkor för programlistan
            if (/^Antal platser$/i.test(L) || /^Antal första/i.test(L) || /^Antal antagna$/i.test(L) || /^Lägsta jämförelsetal$/i.test(L) || CODE_RE.test(L) || /^\d[\d\s.,]*$/.test(L)){
              // stäng programinsamling, splitta
              if (!programs.length){
                programs = splitProgramsFromBuffer(progBuf);
              }
              inPrograms = false;
              // Fortsätt tolka raden igen i “normal” logik (den kan vara Antal platser, Lägsta, eller kodrad)
              // fall-through (ingen continue)
            } else {
              progBuf.push(L);
              continue;
            }
          }

          // 5) Antal platser → efterföljande rad(er) med koder
          if (/^Antal platser$/i.test(L)){
            codesBuf = []; // nollställ
            continue;
          }
          // Kodrad: består nästan bara av koder
          if ((L.match(CODE_RE)||[]).length >= 1 && L.replace(CODE_RE,'').trim().length <= 10){
            codesBuf.push(...(L.match(CODE_RE)||[]));
            continue;
          }

          // 6) Lägsta jämförelsetal → samla tal tills vi når programlängden
          if (/^Lägsta jämförelsetal$/i.test(L)){
            collectingLagsta = true;
            lagstaBuf = [];
            continue;
          }
          if (collectingLagsta){
            const nums = (L.match(NUM_RE)||[]).map(v=>v.replace(',','.'));
            lagstaBuf.push(...nums);
            // Om vi inte vet antal program än (p.g.a. svår splitt) – försök splitta nu
            if (!programs.length && progBuf.length){
              programs = splitProgramsFromBuffer(progBuf);
            }
            if (programs.length && lagstaBuf.length >= programs.length){
              // Sanity: om vi har koder och deras antal ≠ programlängd, försök justera
              if (codesBuf.length && codesBuf.length !== programs.length){
                // Om koderna är fler, trunkera till programlängd
                codesBuf = codesBuf.slice(0, programs.length);
              }
              // Flush en komplett sektion
              flushSection(rows, currentSchool, programs, lagstaBuf, debug);
              // Reset för resterande block i samma skola
              programs = [];
              progBuf = [];
              lagstaBuf = [];
              collectingLagsta = false;
            }
            continue;
          }

          // 7) Ny skola kan komma igen senare – redan hanterat ovan
        }
      }

      // Flush sista hängande blocket om komplett
      if (currentSchool && programs.length && lagstaBuf.length){
        flushSection(rows, currentSchool, programs, lagstaBuf, debug);
      }

      debug.push(`--- Totalt extraherade rader: ${rows.length}`);
      debugEl.textContent = debug.join('\n');
      return rows;
    }

    function renderRows(rows){
      tbody.innerHTML = '';
      rows.sort((a,b)=> (a[0]===b[0] ? a[1].localeCompare(b[1]) : a[0].localeCompare(b[0])));
      for(const [skola,inr,lag] of rows){
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = skola; tr.appendChild(td1);
        const td2 = document.createElement('td'); td2.textContent = inr;   tr.appendChild(td2);
        const td3 = document.createElement('td'); td3.textContent = (isFinite(lag)? String(lag).replace('.',',') : ''); tr.appendChild(td3);
        tbody.appendChild(tr);
      }
      outTable.hidden = rows.length === 0;
      statusEl.textContent = `Klar — ${rows.length} rader`;
      exportCsvBtn.disabled = rows.length === 0;
      exportCsvBtn.onclick = () => exportCSV(rows);
    }

    function exportCSV(rows){
      const header = ['Skola','Inriktning','Lägsta Merit'];
      const esc = s => `"${String(s).replace(/"/g,'""')}"`;
      const fmt = v => (typeof v === 'number' ? String(v).replace('.', ',') : String(v));
      const delimiter = ';';
      const body = rows.map(([a,b,c]) => [esc(a), esc(b), esc(fmt(c))].join(delimiter));
      const csv = [header.map(esc).join(delimiter), ...body].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'antagning_orebro_2025.csv';
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    }

    document.getElementById('parseFileBtn').addEventListener('click', async () => {
      const f = document.getElementById('pdfFile').files[0];
      if(!f){ alert('Välj en PDF-fil först.'); return; }
      statusEl.textContent = 'Läser PDF…';
      outTable.hidden = true; exportCsvBtn.disabled = true;
      try{
        const rows = await parsePdfFromArrayBuffer(await f.arrayBuffer());
        renderRows(rows);
      }catch(err){
        console.error(err);
        statusEl.textContent = 'Fel vid parsning: ' + err.message;
      }
    });

    // Tysta TT-varningen
    try{
      if (pdfjsLib.VerbosityLevel) pdfjsLib.GlobalWorkerOptions.verbosity = pdfjsLib.VerbosityLevel.ERROR;
      const o = console.warn;
      console.warn = (...args) => { if (String(args[0]||'').includes('TT: undefined function')) return; o(...args); };
    }catch{}
  </script>
</body>
</html>
