<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slutlig antagning – parser (filuppladdning)</title>
  <link rel="icon" href="data:," />
  <style>
    :root{ --bg:#0b0f14; --fg:#e7effa; --muted:#94a3b8; --panel:#0f172a; --accent:#22c55e; --border:#1f2937; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:16px 20px;background:#0f172a;border-bottom:1px solid var(--border);position:sticky;top:0;z-index:2}
    main{max-width:1100px;margin:0 auto;padding:20px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input[type=file]{flex:1;min-width:260px;padding:10px;border-radius:10px;border:1px solid var(--border);background:#0f172a;color:var(--fg)}
    button{padding:10px 14px;border-radius:10px;border:0;background:var(--accent);color:#05280f;font-weight:700;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    table{width:100%;border-collapse:collapse;margin-top:20px;background:#0f172a;border:1px solid var(--border);border-radius:12px;overflow:hidden}
    th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left;font-size:14px}
    th{background:#0d1326;position:sticky;top:88px}
    tr:hover td{background:#0c1222}
    .muted{color:var(--muted)}
    details{margin-top:14px}
    pre{white-space:pre-wrap;font-size:12px;background:#0f172a;border:1px solid var(--border);padding:10px;border-radius:8px;max-height:420px;overflow:auto}
    .toolbar{display:flex;gap:8px;margin-top:10px}
    .pill{display:inline-flex;gap:6px;align-items:center;background:#0d1326;border:1px solid #1f2937;border-radius:999px;padding:4px 10px;font-size:12px}
  </style>
</head>
<body>
  <header>
    <div class="row">
      <input id="pdfFile" type="file" accept="application/pdf" />
      <button id="parseFileBtn">Skapa lista från fil</button>
      <span id="status" class="muted"></span>
    </div>
    <div class="toolbar">
      <button id="exportCsvBtn" disabled>Exportera CSV</button>
      <span class="pill"><b>Resultat:</b>&nbsp;Skola · Inriktning · Lägsta Merit</span>
    </div>
  </header>

  <main>
    <table id="outTable" hidden>
      <thead>
        <tr><th>Skola</th><th>Inriktning</th><th>Lägsta Merit</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <details>
      <summary>Visa debug (block för block)</summary>
      <pre id="debugLines"></pre>
    </details>
  </main>

  <script type="module">
    import * as pdfjsLib from './vendor/pdfjs/pdf.mjs';
    const worker = new Worker('./vendor/pdfjs/pdf.worker.mjs', { type: 'module' });
    pdfjsLib.GlobalWorkerOptions.workerPort = worker;

    const statusEl = document.getElementById('status');
    const outTable = document.getElementById('outTable');
    const tbody = outTable.querySelector('tbody');
    const debugEl = document.getElementById('debugLines');
    const exportCsvBtn = document.getElementById('exportCsvBtn');

    const norm = s => (s||'').replace(/\s+/g,' ').trim();
    const canon = s => norm(s)
      .toLowerCase()
      .replace(/å/g,'a').replace(/ä/g,'a').replace(/ö/g,'o')
      .replace(/[–—]/g,'-')
      .replace(/\./g,'');

    const NUM_RE = /(?<!\d)\d{1,3}(?:[.,]\d+)?(?!\d)/g;
    const getNums = s => Array.from((s||'').matchAll(NUM_RE)).map(m=>parseFloat(m[0].replace(',','.')));

    // Bygg rader från pdf.js-items
    function buildLines(items){
      const rowsByY = new Map();
      const yq = 2;
      for(const it of items){
        const y = it.transform[5], x = it.transform[4];
        const key = Math.round(y/yq)*yq;
        if(!rowsByY.has(key)) rowsByY.set(key, []);
        rowsByY.get(key).push({x,str: it.str||''});
      }
      const ys = Array.from(rowsByY.keys()).sort((a,b)=> b-a);
      const lines = [];
      for(const y of ys){
        const bits = rowsByY.get(y).sort((a,b)=> a.x-b.x).map(b=>b.str);
        let line = norm(bits.join(' '));
        if(!line) continue;
        // laga vanliga avstavningar i rubriker
        line = line
          .replace(/forsta-\s*handssokande/gi,'första-handssökande')
          .replace(/Lagsta\s+jamforelsetal/gi,'Lägsta jämförelsetal')
          .replace(/Studievag/gi,'Studieväg')
          .replace(/Medianvarde/gi,'Medianvärde');
        lines.push(line);
      }
      return lines;
    }

    function isSchoolHeader(line){
      // "Slutlig antagningsstatistik för Alléskolan"
      return /^Slutlig antagningsstatistik för\s+/i.test(line);
    }
    function extractSchoolFromHeader(line){
      return line.replace(/^Slutlig antagningsstatistik för\s+/i,'').trim();
    }
    function looksLikeBareSchoolName(line){
      return /(skolan|gymnasiet|gymnasium)\.?$/i.test(line) && !/\d/.test(line);
    }

    // Program-delare: extrahera en lista från en lång rad
    function extractProgramsFromText(t){
      // Fånga: Programinriktat val mot …  |  Yrkesintro. mot …  |  …progr. / …programmet  [valfri " - ..." svans]
      const RE = /(Programinriktat val mot [^\.]+\.|Yrkesintro\.\s*mot [^\.]+\.|[A-Za-zÅÄÖåäöÉéÜüÏïÖö\- ]+?(?:progr\.|programmet)(?:\s*-\s*[A-Za-zÅÄÖåäöÉéÜüÏïÖö\- ]+)?)/g;
      const out = [];
      let m; 
      while((m = RE.exec(t)) !== null){
        const s = norm(m[0].replace(/\bprogrammet\b/i,'progr.'));
        if(s.length>4) out.push(s);
      }
      return out;
    }

    // Läs ett helt "Studieväg"-block: rubriker kan ligga över flera rader,
    // programlistan är ofta en (eller två) rader, därefter kommer kolumnhinkar med siffror
    function parseBlock(lines, startIdx, debug, school){
      const resultRows = [];

      // 1) samla headerfönster runt "Studieväg"
      const headerWindow = [];
      for(let i=startIdx; i<Math.min(lines.length, startIdx+12); i++){
        const L = lines[i];
        headerWindow.push(L);
        // bryt när vi når tydligt nästa sektion (ny skola eller ny "Studieväg")
        if(i>startIdx && (isSchoolHeader(L) || looksLikeBareSchoolName(L) || /^Slutlig antagningsstatistik/i.test(L) || /^Studieväg$/.test(L))){
          break;
        }
      }
      const headerText = canon(headerWindow.join(' '));
      // Försök härleda ordningen – vi söker i rätt sekvens och tar första träffordningen
      const headerKeys = ['antal platser','antal första-handssökande','antal forsta-handssokande','antal antagna','lägsta jämförelsetal','lagsta jamforelsetal','medianvärde','medianvarde','antal reserver'];
      const keyMap = {
        'antal platser':'platser',
        'antal första-handssökande':'forstahand',
        'antal forsta-handssokande':'forstahand',
        'antal antagna':'antagna',
        'lägsta jämförelsetal':'lagsta',
        'lagsta jamforelsetal':'lagsta',
        'medianvärde':'median',
        'medianvarde':'median',
        'antal reserver':'reserver'
      };
      const order = [];
      for(const k of headerKeys){
        if(headerText.includes(canon(k))){
          const key = keyMap[k];
          if(!order.includes(key)) order.push(key);
        }
      }
      if(!order.includes('lagsta')){
        debug.push(`  [WARN] Hittade inte rubrikordning med "Lägsta" i blocket – hoppar.`);
        return { nextIdx: startIdx+1, rows: [] };
      }
      debug.push(`  [ORDER] ${order.join(', ')}`);

      // 2) leta programraden (1–3 rader) efter headerfönstret
      let progText = '';
      let iProgStart = startIdx+1;
      for(let i=iProgStart;i<Math.min(lines.length, iProgStart+8); i++){
        const L = lines[i];
        if(/Studieväg/i.test(L)) continue;
        // heuristik: rad som innehåller minst två "progr." eller "Yrkesintro."/ "Programinriktat val"
        const cnt = (L.match(/progr\./gi)||[]).length + (L.match(/Yrkesintro\./gi)||[]).length + (L.match(/Programinriktat val/gi)||[]).length;
        if(cnt>=1){ // ibland delas på två rader
          progText += ' ' + L;
          // fortsätt en rad till om nästa också ser ut som fortsättning
          if((lines[i+1]||'').match(/progr\.|Yrkesintro\.|Programinriktat val/i)) {
            continue;
          }
          iProgStart = i+1;
          break;
        }
      }
      const programs = extractProgramsFromText(progText);
      if(programs.length === 0){
        debug.push(`  [WARN] Fann inga program i blocket – hoppar.`);
        return { nextIdx: startIdx+1, rows: [] };
      }
      debug.push(`  [PROGRAM] ${programs.length} st`);

      // 3) samla kolumnhinkar (siffror) i ordning efter header
      const buckets = { platser:[], forstahand:[], antagna:[], lagsta:[], median:[], reserver:[] };
      let cursor = iProgStart;
      // läs framåt tills nästa skola/Studieväg/sektion
      // vi fyller hinkar i headerordning; varje hink kan spilla över flera rader
      const stopRe = /^(Slutlig antagningsstatistik|Studieväg|[A-Za-zÅÄÖåäö].*(skolan|gymnasiet|gymnasium)\.?)$/i;
      for(const key of order){
        const arr = [];
        while(cursor < lines.length){
          const L = lines[cursor];
          if(stopRe.test(L)) break;
          const nums = getNums(L);
          if(nums.length){
            arr.push(...nums);
            cursor++;
            // om vi redan har minst lika många tal som program – gå vidare till nästa hink
            if(arr.length >= programs.length) break;
            continue;
          }
          // icke-numerisk rad: om den är en kodrad (AE/DEM/… upprepat) – ignorera; annars kan det vara nästa sektion
          if(/\b([A-ZÅÄÖ]{2,3}\s+){3,}\b/.test(L)){ cursor++; continue; }
          // annars bryt hink
          break;
        }
        buckets[key] = arr.slice(0, programs.length);
        debug.push(`  [${key}] ${buckets[key].length} värden`);
      }

      // 4) bygg rader (bara om vi har minst någon "lagsta")
      const L = buckets.lagsta || [];
      const n = Math.min(programs.length, L.length);
      if(n === 0){
        debug.push(`  [WARN] 0 Lägsta-värden – hoppar blocket.`);
      }else{
        for(let i=0;i<n;i++){
          resultRows.push([school, programs[i], L[i]]);
        }
      }

      // 5) hitta rimligt nextIdx (sluta när vi träffar nästa skola/Studieväg/sektion)
      let nextIdx = cursor;
      while(nextIdx < lines.length){
        if(stopRe.test(lines[nextIdx])) break;
        nextIdx++;
      }
      return { nextIdx, rows: resultRows };
    }

    async function parsePdfFromArrayBuffer(buf){
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      const debug = [];
      const rows = [];
      let currentSchool = null;

      for(let p=1; p<=pdf.numPages; p++){
        const page = await pdf.getPage(p);
        const text = await page.getTextContent();
        const lines = buildLines(text.items);

        // debug: visa ett axplock från sidan
        for(const L of lines.slice(0,60)) if (debug.length < 300) debug.push(L);

        for(let i=0; i<lines.length; i++){
          const line = lines[i];

          if(isSchoolHeader(line)){
            currentSchool = extractSchoolFromHeader(line);
            debug.push(`[SKOLA] ${currentSchool}`);
            continue;
          }
          if(looksLikeBareSchoolName(line)){
            currentSchool = line.trim();
            debug.push(`[SKOLA] ${currentSchool}`);
            continue;
          }

          if(/^Studieväg$/i.test(line)){
            if(!currentSchool){
              debug.push(`  [WARN] Studieväg utan aktuell skola – hoppar.`);
              continue;
            }
            const { nextIdx, rows: blockRows } = parseBlock(lines, i, debug, currentSchool);
            rows.push(...blockRows);
            i = Math.max(i+1, nextIdx-1);
          }
        }
      }

      debug.push(`--- Totalt extraherade rader: ${rows.length}`);
      debugEl.textContent = debug.join('\n');
      return rows;
    }

    function renderRows(rows){
      tbody.innerHTML = '';
      rows.sort((a,b)=> (a[0]===b[0] ? a[1].localeCompare(b[1]) : a[0].localeCompare(b[0])));
      for(const [skola,inr,lag] of rows){
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = skola; tr.appendChild(td1);
        const td2 = document.createElement('td'); td2.textContent = inr;   tr.appendChild(td2);
        const td3 = document.createElement('td'); td3.textContent = (typeof lag==='number'? String(lag).replace('.',',') : String(lag)); tr.appendChild(td3);
        tbody.appendChild(tr);
      }
      outTable.hidden = rows.length === 0;
      statusEl.textContent = `Klar — ${rows.length} rader`;
      exportCsvBtn.disabled = rows.length === 0;
      exportCsvBtn.onclick = () => exportCSV(rows);
    }

    function exportCSV(rows){
      const header = ['Skola','Inriktning','Lägsta Merit'];
      const esc = s => `"${String(s).replace(/"/g,'""')}"`;
      const fmt = v => (typeof v === 'number' ? String(v).replace('.', ',') : String(v));
      const delimiter = ';';
      const body = rows.map(([a,b,c]) => [esc(a), esc(b), esc(fmt(c))].join(delimiter));
      const csv = [header.map(esc).join(delimiter), ...body].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'antagning_orebro_2025.csv';
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    }

    document.getElementById('parseFileBtn').addEventListener('click', async () => {
      const f = document.getElementById('pdfFile').files[0];
      if(!f){ alert('Välj en PDF-fil först.'); return; }
      statusEl.textContent = 'Läser PDF…';
      outTable.hidden = true; exportCsvBtn.disabled = true;
      try{
        const rows = await parsePdfFromArrayBuffer(await f.arrayBuffer());
        renderRows(rows);
      }catch(err){
        console.error(err);
        statusEl.textContent = 'Fel vid parsning: ' + err.message;
      }
    });

    // Tysta TT-varningen
    try{
      if (pdfjsLib.VerbosityLevel) pdfjsLib.GlobalWorkerOptions.verbosity = pdfjsLib.VerbosityLevel.ERROR;
      const o = console.warn;
      console.warn = (...args) => { if (String(args[0]||'').includes('TT: undefined function')) return; o(...args); };
    }catch{}
  </script>
</body>
</html>
